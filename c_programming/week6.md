<!--
 * @Date: 2020-07-10 10:54:36
 * @Author: Dai Zhechen
 * @Github: https://github.com/zhechendai
 * @LastEditTime: 2020-07-10 14:01:35
 * @Copyright ©️ 2020 Dai Zhechen. All Rights Reserved.
--> 

函数
====

函数的定义和使用
----

eg. 素数求和
* 原来的代码（左）循环板块很大
* 将判断是否为素数的代码单独拿出（中），变成自定义函数
* （右）中使用自定义函数，使循环代码块缩小

![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/IMG_5F15B5246AC4-1.jpeg)

eg. 求和

```c
int i;
int sum;

for(i=1, sum=0; i<=10; i++){
    sum += i;
}
printf("%d到%d的和是%d\n",1, 10, sum);

for(i=20, sum=0; i<=30; i++){
    sum += i;
}
printf("%d到%d的和是%d\n",20, 30, sum);

for(i=35, sum=0; i<=45; i++){
    sum += i;
}
printf("%d到%d的和是%d\n",35, 45, sum);
```

>这个示例中有三段几乎一摸一样的代码  
代码复制是程序质量不良的表现  
维护时可能需要维护很多处

![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/IMG_2E09DA854284-1.jpeg)

什么是函数
* 函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值
* 可以先想像成数学中的函数（不完全一样）
  * $$y=f(x)$$

函数定义

![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/IMG_747E241DAA45-1.jpeg)

>这里的返回类型`void`表示不返回任何东西

调用函数
* 函数名（参数值）
* ()起到了表示函数调用的重要作用
  * 即使没有参数也要使用()
* 如果有参数，则需要给出正确的数量和顺序
* 这些值会被按照顺序依次用来初始化函数中的参数
* 函数知道每一次是哪里调用它，会返回到正确的地方

从函数中返回

![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/11.43.29.png)

* return停止函数的执行，并送回一个值（可以有两种情况，如下）
  * `return;`
  * `return 表达式;`
* 一个函数里可以出现多个return语句，例如
```c
int max(int a, int b)
{
    // int ret;
    if( a>b ){
        return a;
    }else{
        return b;
    }
    // return ret;
}
```
>这样写不符合但已出口的理念，但运行没有问题

* 从函数中返回值
  * 可以赋值给变量
  * 可以再传递给函数
  * 甚至可以丢弃
    * 有的时候要的是副作用
* 没有返回值的函数
  * void函数名（参数表）
  * 不能使用带值的return
    * 可以没有return
  * 调用的时候不能做返回值的赋值
* **如果函数有返回值，则必须使用带值的return**

？为什么要用函数
* 使程序的结构更简便，使程序模块化了，而且编程可以直接调用，不用每次都编写

函数的参数和变量
----

函数原型

函数先后关系
* 一般把函数（例如`sum()`）写在程序最前面，是因为
   * C的编译器**自上而下**顺序分析你的代码
   * 在看到`sum(1,10)`的时候，它需要知道`sum()`的样子
     * 也就是`sum()`要几个参数，每个参数的类型如何，返回什么类型
     * 这样它才能检查你对`sum()`的调用是否正确

* 如果把要调用的函数放到了程序的下面
  * 旧标准会假设你所调用的函数所有的参数都是int，返回也是int
  * 如果与你接下来自定义的函数的类型不同：会有冲突，error出现
* 一般程序我们希望先看到程序主题，再去看程序中使用函数的细节
* ？如何避免以上冲突
  * 在程序最开始定义一下**函数原型**

函数原型
* 函数头，以分号“;”结尾，就构成了函数的原型
* 函数原型的目的是告诉编译器这个函数长什么样，告诉了：
  * 名称
  * 参数（数量及类型）
  * 返回类型
* 旧标准习惯把函数原型写在调用它的函数里面
* 现在一般写在调用它的函数前面
* 原型里可以不写参数的名字，但是一般仍然写上（为了人类阅读的方便）

参数传递
* 如果函数有参数，调用函数时必须传递给它数量、类型正确的值
* 可以传递给函数的值是表达式的结果，这包括：
  * 字面量
  * 变量
  * 函数的返回值
  * 计算的结果

![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/12.20.25.png)

类型不匹配？
* 调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞
* 编译器总是悄悄地替你把类型转换好，但是这很可能不是你所期望的（例如将double类型转换成int类型）
* 后续的语言，C++/ Java在这方便很严格

传过去的是什么？
* C语言在调用函数时，永远只能传值给函数

传值
* 每个函数与自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系
* 过去，对于函数参数表中的参数，叫做“形式参数”，调用函数时的值，叫做“实际参数”  
![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/1.17.31.png) 
* 由于容易让初学者误会实际参数就是实际在**函数中进行计算的参数**，误会调用函数的时候把变量而不是值传进去了，所以我们不建议继续使用这种古老的方式来称呼它们
* 我们认为，他们是参数和值的关系  
![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/1.19.03.png)
  
本地变量
* 函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的**这次运行所独有的**，称作本地变量
* 定义在函数内部的变量就是本地变量
* 参数也是本地变量

变量的生存期和作用域
* 生存期：什么时候这个变量出现了，到什么时候这个变量它消亡了
* 作用域：在（代码的）什么范围内可以访问这个变量（这个变量可以起作用）
* 对于本地变量，这两个问题的答案是统一的：大括号内——块

本地变量的规则
* 本地变量是定义在块{}内的
  * 它可以是定义在函数的块内
  * 也可以是定义在语句的块内
  * 甚至可以随便拉一对大括号来定义变量
* 程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了
* 块外面定义的变量在里面仍然有效
* 块里面定义了和外面同名的变量则覆盖了外面的
* 不能在一块内定义同名的变量
* 本地变量就不会被默认初始化
* 参数在进入函数的时候被初始化了

其他细节
* 函数没有参数时
  * `void f(void)`
    * 建议使用这种
  * `void f()`
    * 在传统C中，它表示f函数的参数未知，并不表示没有参数
    * C99中，出现的情况类似没有申明函数原型，会先猜测类型是int

逗号运算符
* 调用函数时的圆括号里的逗号是标点符号，不是运算符，例如
  * `f(a,b)`此时为标点符号逗号
  * `f((a,b))`此时为位运算符逗号，先完成内括号内的运算

函数里的函数？
* C语言不允许函数的嵌套定义
* 可以在函数里放另外一个函数的声明，但不能放另外一个函数的定义

关于main
* `int main()`也是一个函数
* 要不要写成`int main(void)`
  * 可以在里面加void
  * main()有返回值，加个void就表示函数不需返回值
* `return 0;`的0有人看吗？
  * 有