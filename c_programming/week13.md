<!--
 * @Date: 2020-07-18 15:23:01
 * @Author: Dai Zhechen
 * @Github: https://github.com/zhechendai
 * @LastEditTime: 2020-07-18 18:03:39
 * @Copyright ©️ 2020 Dai Zhechen. All Rights Reserved.
--> 

程序结构
====

全局变量
----

* 定义在函数外面的变量是全局变量
* 全局变量具有全局的生存期很作用域
  * 它们与任何函数都无关
  * 在任何函数内部都可以使用它们

本地变量
* 生存期和作用域是一致的，在函数内部
* 函数开始时，产生；函数结束后，消失

全局变量初始化
* 没有做初始化的全局变量会得到0值（本地变量不做初始化会得到乱七八糟的值）
  * 指针会得到NULL值
* 只能用编译时刻已知的值来初始化全局变量
* 它们的初始化发生在main函数之前

被隐藏的全局变量
* 如果函数内部存在与全局变量同名的变量，则全局变量被隐藏

静态本地变量
* 在本地变量定义时加上**static**修饰符就成为静态本地变量
* 当函数离开时，静态本地变量会**继续存在并保持其值**
* 静态本地变量的初始化只会在**第一次**进入这个函数时做，以后进入函数会保持**沿用上次离开时的值**

* 静态本地变量实际上是特殊的全局变量
* 它们位于相同的内存区域
* 静态本地变量具有全局的生存期，函数内的局部作用域
  * static在这里的意思是局部作用域（本地可访问）（**全局生存区，但只有本地作用域**）

*返回指针的函数
* 返回本地变量的地址是危险的
* 返回全局变量或静态本地变量的地址是安全的
* 返回在函数内malloc的内存是安全的，但是容易造成问题
* 最好的做法是返回传入的指针

tips
* 不要使用全局变量在函数间传递参数和结果
* 竟然避免使用全局变量
* *使用全局变量和静态本地变量的函数是线程不安全的

编译预处理和宏
----

宏定义

编译预处理指令
* \#开头的是编译预处理指令
* 它们不是C语言的成分，但是C语言程序离不开它们
* \#define用来定义一个宏

\#define
* \#define<名字><值>
* 注意没有结尾的分号，因为不是C的语句
* 名字必须是一个单词，值可以是各种东西
* 在C语言的编译器开始编译之前，编译预处理程序（cpp）会把程序中的名字替换成值（.i文件）
  * 是完全的文本替换
* gcc --save-temps可以查看编译过程中产生的所有文件

宏
* 如果一个宏的值中有其他宏的名字，也是会被替换的
* 如果一个宏的值超过一行，最后一行之前的行末需要加`\`
* 宏的值后面出现的注释不会被当作宏的值的一部分

定义没有值的宏
* \#define _DEBUG
* 这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了

C编译器中预先定义的宏
```c
_LINE_
_FILE_
_DATE_
_TIME_
_STDC_
```

带参数的宏

像函数的宏
* \#define cube(x) ((x)\*(x)*(x))
* 宏可以带参数

错误定义的宏
* \#define RADTODEG(x)(x*57.29578)
* \#define RADTODEG(x)(x)*57.29578

带参数的宏的原则
* 一切都要括号
  * 整个值要括号
  * 参数出现的每个地方都要括号
* \#define RADTODEG(x)((x)*57.29578)

* 可以带多个参数
  * \#define MIN(a,b)((a)>(b)?(b):(a))
* 也可以组合（嵌套）使用其他宏

>切记宏的定义最后不要加`;`

* 带参数的宏在大型程序的代码中使用非常普遍（效率高，但会牺牲空间，因为要展开）
* 可以非常复杂，如“产生”函数
  * 在`#`和`##`这两个运算符的帮助下
* 部分宏会被inline函数代替

其他编译预处理指令
* 条件编译
* error
* ...


大程序结构
----

多个.c文件
* main()里面的代码太长了适合分成几个函数
* 一个源代码文件太长了适合分成几个文件
* 两个独立的源代码文件不能编译形成可执行的程序

编译单元
* 一个.c文件是一个编译单元
* 编译器每次编译只处理一个编译单元

项目
* 在Dev C++中新建一个项目，然后把几个源代码文件加入进去
* 对于项目，Dev C++的编译会把一个项目中所有的源代码文件都编译后，链接起来
* 有的IDE有分开的编译和构建两个按钮，前者是对单个原文件代码编译，后者是对整个项目做链接

头文件

函数原型
* 如果不给出函数原型，编译器会猜测你所调用的函数的所有参数都是int，返回类型也是int
* 编译器在编译的时候只看当前的一个编译单元，它不会去看同一个项目中的其他编译单元以找出那个函数的原型
* 如果你的函数并非如此，程序链接的时候不会出错
* 但是执行的时候就不对了
* 所以需要在调用函数的地方给出函数的原型，以告诉编译器那个函数究竟长什么样
>此时需要头文件

头文件
* 把函数原型放到一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中#include这个头文件，就能让编译器在编译的时候知道函数的原型
  
\#include
* \#include是一个编译预处理指令，和宏一样，在编译之前就处理了
* 它把那个文件的全部文本内容原封不动地插入到它所在的地方
  * 所以也不是一定要在.c文件的最前面#include

include使用`""`还是`<>`
* \#include有两种形式来指出要插入的文件
  * `""`要求编译器首先在当前目录（.c文件所在的目录中）寻找这个文件，如果没有，到编译器指定的目录去找
  * `<>`让编译器只在指定的目录去找
* 编译器自己知道自己的标准库的头文件在哪里
* 环境变量和编译器命令行参数也可以指定寻找头文件的目录

\#include的误区
* \#include不是用来引入库的
* stdio.h里只有printf的原型，printf的代码在另外的地方，某个.lib(Windows)或.a(Unix)中
* 现在的C语言编译器默认会引入所有的标准库
* \#include <stdio.h>只是为了让编译器知道printf函数的原型，保证你调用时给出的参数值是正确的类型

对外公开的函数
* 在使用和定义这个函数的地方都应该有#include这个头文件
* 一般的做法就是任何.c都有对应的同名的.h, 把所有对外公开的函数的原型和全局变量的声明都放进去
不对外公开的函数
* 在函数前面加上static就使得它成为只能在所在的编译单元中被使用的函数
* 在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量

声明

变量的声明
* `int i;`是变量的定义
* `extern int i;`是变量的声明

声明和定义
* 声明是不产生代码的东西
  * 函数声明
  * 变量声明
  * 结构声明
  * 宏声明
  * 枚举声明
  * 类型声明
  * inline函数
* 定义是产生代码的东西

声明&头文件
* 只有声明可以被放在头文件中
* 否则会造成一个项目中多个编译单元里有重名的实体
  * *某些编译器允许几个编译单元中存在同名的函数，或者用weak修饰符来强调这种存在

重复声明
* 同一个编译单元里，同名的结构不能被重复声明
* 如果你的头文件里有**结构的声明**，很难这个头文件不会在一个编译单元里被#include多次
* 所以需要“标准头文件结构”

标准头文件结构，如下

```c
#ifndef _LIST_HEAD_
#define _LIST_HEAD_

#include "node.h"

typedef struct _list {
    Node* head;
    Node* tail;
} List;

#endif
```
* 运用条件编译和宏，保证这个头文件在一个编译单元中只会被#include一次
* visual Studio中#pragma once也能起到相同的作用，但是不是所有的编译器都支持

*向前声明

```c
#ifndef _LIST_HEAD_
#define _LIST_HEAD_

struct Node;

typedef struct _list {
    struct Node* head;
    struct Node* tail;
} List;

#endif
```
* 因为在这个地方不需要具体知道Node是怎么样，所以可以用struct Node来告诉编译器Node是一个结构