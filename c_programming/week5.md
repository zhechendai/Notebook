<!--
 * @Date: 2020-07-09 10:41:20
 * @Author: Dai Zhechen
 * @Github: https://github.com/zhechendai
 * @LastEditTime: 2020-07-09 18:15:03
 * @Copyright ©️ 2020 Dai Zhechen. All Rights Reserved.
--> 


数据类型
====

C语言是一种有类型的语言
* C语言的变量，必须
  * 在使用前定义，并且
  * 确定类型（int, double...）
* C语言之后的语言向两个方向发展：
  * c++/ Java更强调类型，对类型的检查更严格
  * JavaScript, Python, PHP不看重类型，甚至不需要事先定义

类型安全
* 支持强类型的观点认为明确的类型有助于尽早发现程序中的简单错误
* 反对强类型的观点认为过于强调类型迫使程序员面对底层、实现而非事务逻辑
* 总的来说，早期语言强调类型，面向底层的语言强调类型
* C语言需要类型，但是对类型的安全检查并不够

C语言类型
>加粗为C99的类型，其余的是基本类型

* 整数
  * char, short, int, long, **long long** 
* 浮点数
  * float, double, **long double** 
* 逻辑
  * **bool** 
* 指针
* 自定义类型

数据类型有何不同
* 类型名称: int, long, double
* 输入输出时的格式: %d, %ld, %lf
* 所表达的数的范围: char(1字节)< short(2字节)< int(4字节)< float(4字节)< double(8字节)< long double(8字节)
* 内存中所占据的大小: 1字节-16字节
* 内存中的表达形式: 二进制数(补码)(整型数据), 编码(浮点数)(不能直接做计算)
>后两个是数据在计算机内部的不同

`sizeof()`

* 是一个运算符，给出某个类型或者变量在内存中所占据的字节数
  * sizeof(int)
  * sizeof(i)
* 是静态运算符，它的结果在编译时刻就决定了
* 不要再sizeof()括号中做运算，这些运算不会被计算机做的

```c
#include <stdio.h>
int main()
{
    int a;
    a = 6;

    printf("sizeof(double)=%ld\n", sizeof(double));
    printf("sizeof(a)=%ld\n", sizeof(a));

    return 0;
}
```

整数类型

* char 1字节（8比特）
* short 2字节
* int 取决于编译器（CPU），通常的意义是“1个字”
* long 取决于编译器（CPU），通常的意义是“1个字”
* long long 8字节
>int用来表示寄存器的大小

整数的内部表达
* 计算机内部一切都是二进制
  * 18 --> 00010010
  * -18 --> ?
* 如何表示负数
  * 十进制用“-”来表示负数，在做计算的时候
    * 加减是做相反的运算
    * 乘除时当作正数，计算完毕对结果的符号取反
  * 二进制表示负数
    * 补码：11111111
    * 加上：00000001后等于(1)00000000
    * 数据为8比特，此时结果溢出，实际得到的结果为 00000000
* 综上，同理，对于$$-a$$，其补码就是$$0-a$$，实际是$$2^n-a$$, $$n$$是这种类型的位数（int下$$n$$为8）
* 补码的意义就是拿补码和原码可以加出一个溢出的“零”


数的范围
* 对于一个字节（8位），可以表达的是
  * 00000000 ~ 11111111
* 其中
  * 00000000 --> 0
  * 11111111 ~ 10000000 --> -1 ~ -128（由大到小，在这里将二进制数当成补码来看待）
  * 00000001 ~ 01111111 --> 1 ~ 127
>取决与我们看待的方式，例如11111111，看成纯2进制，那就是256；看成1个字节类型的整数，那就是-1

```c
// 验证
char c = 255; // 1字节8位类型
int i = 255;  // 4字节32位类型
printf("c=%d, i=%d", c, i);
// 输出结果为：c=-1, i=255
// char类型，计算机中的是 11111111 
// int类型，计算机中的是 00000000 00000000 00000000 11111111
```
* char 1字节（8比特）-128 ~ 127
* short 2字节 -32768 ~ 3277
* int 取决于编译器（CPU），通常的意义是“1个字” $$-2^{32-1}\;\sim\;2^{32-1}-1$$
* long 取决于编译器（CPU），通常的意义是“1个字”
* long long 8字节

unsigned

* 内部二进制表达没有改变，改变的是如何看待（如何输出）
* 当成纯二进制数
* 这个整数不以补码的形式来看待
* 使用后能表达的正数范围扩大一倍

```c
// 验证
unsigned char c = 255; // 1字节8位类型
printf("c=%d, c, i);
// 输出结果为：c=255
```

* 如果一个字面量常数想哟啊表达自己是unsigned，可以在后面加上u或者U，如，255U
* 补充：可以用l或者L表示long(long)
>unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位

整数的越界
* 整数是以纯二进制方式进行计算的

整数的输入和输出
* `printf()`, `scanf()`只有两种形式：int或long long
  * %d: int
  * %u: unsigned
  * %ld: long long
  * %lu: unsingned long long

```c
char c = -1;
int i = -1;
printf("c=%u, i=%u", c, i);   // 输出为%u, unsigned
// 输出结果为：c=4294967295, i=4294967295  unsigned时 32位全为的1的值。
// 虽然c的类型定义为char，但是进入到`printf()`中时，自动转换成int类型
```

8进制 & 16进制
* 一个以`0`开始的数字字面量是8进制
* 一个以`0x`开始的数字字面量是16进制
* `%o`用于8进制 `%x`用于16进制
* 8进制和16进制只是如何将数字表达为字符串，与内部如何表达数字无关

```c
char c = 012;   // 只是我们看到的是8进制，16进制
int i = 0x12;   // 计算机内部只有2进制，编译器将所有进制全都转化成了2进制
printf("c=%d, i=%d", c, i);  // 全部输出为10进制
// 输出结果为：c=10, i=18
```

```c
char c = 012;   // 只是我们看到的是8进制，16进制
int i = 0x12;   // 计算机内部只有2进制，编译器将所有进制全都转化成了2进制
printf("c=%o, i=%x", c, i);  // 分别输出为8进制和16进制
// 输出结果为：c=12, i=11
```

>* 16进制很适合表达二进制数据，因为4位二进制正好是一个16进制位，刚好是一个char  
>* 8进制的一位数字正好表达3位二进制  
>   * 因为早期计算机的字长是12的倍数，而非8


选择数据类型
* 为了准确的表达内存，做底层程序的需要
* 没有特殊情况，就选择int
  * 现在的CPU的字长普遍是32位或64位，一次内存读写就是一个int，一次计算也是一个int，选择更短的类型不会更快，甚至更慢
  * 现代编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个int的大小（虽然sizeof告诉你更小）
* unsigned与否只是输出结果的不同，内部计算是一样的（某些特殊位运算）

浮点数类型

类型 | 字长 | 范围 | 有效数字 |
:---: | :-----:| :----:| :-------: |
float | 32 | $$\pm(1.20\times10^{-38}\;\sim\;3.40\times10^{38}),\;0,\;\pm inf,\;nan$$ | 7 
double | 64 | $$\pm(2.2\times10^{-308}\;\sim\;1.79\times10^{308}),\;0,\;\pm inf,\;nan$$ | 15 

浮点的输入输出

类型 | `scanf()` | `printf()` |
:--: | :------: | :-------: |
float | %f | %f, %e 
double | %lf | %f, %e 

>e% 输出的是以科学计数法表示的数

输出精度
* 在%和f之间加上`.n`可以指定输出小数点后几位，这样的输出是做四舍五入的
```c
printf("%.3f\n", -0.0049);
printf("%.30f\n", -0.0049);
printf("%.3f\n", -0.00049);
// 输出结果为：
// -0.005
// -0.004899999999999999841793218991
// -0.000
```

超出范围的浮点数
* `printf()`输出inf表示超出范围的浮点数：$$\pm\infty$$
* `printf()`输出nan表示不存在的浮点数

```c
printf("%f\n", 12.0/0.0);
printf("%f\n", -12.0/0.0);
printf("%f\n", 0.0/0.0);
// 输出结果为：
// inf
// -inf
// nan
printf("%d\n", 12/0);
// 编译时不通过，整数不能表达无穷大，浮点数的有效范围内不包含无穷大，它将正负无穷大，不能表示的数，定义了三种特殊情况
```

* 浮点的运算没有精度
* 带小数点的字面量是double而非float
* float需要用f或者F后缀来表明身份

```c
float a, b, c;
a = 1.345f;
b = 1.123f;
c = a + b;
if (c == 2.468)
{
    printf("相等\n");
else
{
    printf("不相等！c=%.10f,或%f\n", c, c);
}
// 输出结果为：
// 不相等！c=2.4679999352,或2.468000
// float前6位数是精确的，后不准确，会四舍五入
```

* f1 == f2可能失败
* fabs(f1-f2) < 1e-12    来判断
* 浮点数运算，误差会累积
*  转换成用整数计算，整数计算一定是精确的
*  使用bcd计算

浮点数的内部表达
![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/2.19.40.png)
* 浮点数在计算是由专用的硬件部件实现的
* 计算double和float所用的部件是一样的

选择浮点的类型
* 如果没有特殊需求，只使用double
* 现在CPU能直接对double做硬件计算，性能不会比float差，在64位的计算机上，储存数据的速度也不会比float慢

字符类型
* char是一种整数，也是一种特殊的类型：字符
  * 用单引号表示的字符字面量：'a', '1'
  * ''也是一个字符
  * `printf()` `scanf()`里用%c来输入和输出字符

字符计算
* 一个字符加一个数字得到ASCII码表中那个数之后的字符
* 两个字符的减，得到他们在表中的距离
* 字母在ASCII表中是顺序排列的
* 大写字母和小写字母是分开排列的，并不在一起
* 'a'-'A'可以得到两段之间的距离，于是
  * a+'a'-'A'可以把一个大写字母变成小写字母，而
  * a+'A'-'a'可以把一个小写字母变成大写字母

逃逸字符
* 用来表示无法印出来的控制字符或者特殊字符，它由一个反斜杠“\”开头，后面跟上另一个字符，这两个字符组合起来构成一个字符

![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/2.40.34.png)

类型转换

自动类型转换
* 当运算符的两边出现不一致的类型时，会自动转换成较大的类型
  * 大的意思是能表达的数的范围更大
  * char --> short --> int --> long --> long long
  * int --> float --> double
  * 对于printf(),任何小于int的类型会被转换成int；float会被转换成double
  * 但是scanf()不会，要输入short，需要%hd
强制类型转换
* 要把一个量强制转换成另一个类型（通常是较小的类型），需要
  * （类型）值
  * 比如
    * (int)10.2
    * (short)32
  * 注意这时候的安全性，小的变量不总能表达大的量
    * (short)32768

```c
printf("%d\n",32768);
printf("%d\n",(short)32768);
printf("%d\n",(char)32768);
// 输出结果为：
// 32768
// -32768
// 0
```
* 只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型都不改变

```c
int i = 32768;
short s = (short)i;
char c = (char)i;

printf("%d\n", s);
printf("%d\n", c);
printf("%d\n", i);
// 输出结果为：
// -32768
// 0
// 32768
```

* 强制类型转换的优先级高于四则运算
![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/3.04.30.png)

？如何转换的
>当将数值类型转换成大于本身类型时，数值大小不变。当将数值类型转换成小于本身类型时，会在内存单元中进行截取有效位数

以下哪种类型不能用在switch-case的判断变量中：
- [ ]A.char
- [ ]B.short
- [ ]C.int
- [x]D.double
>因为浮点数不精确

其他运算：逻辑、条件、逗号
----

逻辑类型bool
* `#include <stdbool.h`
* 之后就可以使用bool和true, false
* bool实际上还是以int的手段实现的，所以可以当作int来计算
* 也只能当作int来输入和输出

```c
bool b = 6>5;
bool t = true;
t = 2;
printf("%d\n", b);
printf("%d\n", t);
// 输出结果为：
// 1  bool输出1为true，0为false
// 1
```
>`printf()`无法输出`true`或者`false`

逻辑运算
* 逻辑运算是对逻辑量进行的运算，结果只有**0或1**
* 逻辑量是关系运算或逻辑运算的结果
![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/5.15.47.png)

表达数学区间
>解决之前作业中的问题

* 数学区间为$$x\in(4,6)$$或者$$x\in\lbrack4,6\rbrack$$
```c
x>4 && x<6
x>=4 && x<=6
```
* 判断一个字符c是否是大写字母
```c
c>='A' && c<='Z'
```

优先级
* ! > && > ||

![](https://gitbook-daizhechen.oss-cn-hangzhou.aliyuncs.com/notesstack/5.26.39.png)

短路

* 逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算
  * a==6 && b==1
  * a==6 && b+=1
* 对于&&，左边是false时就不做右边了
* 对于||，左边是true时就不做右边了

```c
int a = -1;
if (a>0 && a++)
{
    printf("ok\n");
}
printf("%d\n", a);
// 输出结果为：
// -1
// 表明 a++并没有被执行
```

>不要把赋值，包括复合赋值组合进表达式

条件运算

条件运算符

```c
count = (count>20)? count-10 : count+10
// 条件? 条件满足时的值: 条件不满足时的值
// 可以转化为：
if(count>20)
    count = count-10;
else
    count = count+10;
```

嵌套条件表达式
* 条件运算符是自右向左结合的
* 不希望使用嵌套的条件表达式（可读性差，易出错）

逗号运算
* 逗号用来连接两个表达式，并以其右边的表达式的值作为它的结果
* 逗号的优先级是所有运算符中最低的，所以它两边的**表达式会先计算**
* 逗号的组合关系是自左向右，所以**左边的表达式会先计算**，而**右边**的表达式的值就**留下来作为逗号运算的结果**
```c
int i = 3+4, 5+6
printf("%d\n", i);
//  输出结果为：7 （赋值优先级高于逗号）
int i = (3+4, 5+6)
printf("%d\n", i);
//  输出结果为：11
```

一般在for中使用
```c
for(i=0, j=10; i<j; i++; j--)...
```
